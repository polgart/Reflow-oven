<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Reflow Oven: C:/Users/EDU_OBOS_5057/Documents/Reflow oven/Design/SW/RO_firmware_v1.X/mcc_generated_files/i2c1.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Reflow Oven
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Budapesti Műszaki és Gazdaságtudományi Egyetem</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d522931ffa1371640980b621734a4381.html">Users</a></li><li class="navelem"><a class="el" href="dir_0f947898106c48d9e58de08ab5a86050.html">EDU_OBOS_5057</a></li><li class="navelem"><a class="el" href="dir_2b4b7038549cfaf5b533adb1a9e76356.html">Documents</a></li><li class="navelem"><a class="el" href="dir_163ee0286806ad55d98a3407bd663cea.html">Reflow oven</a></li><li class="navelem"><a class="el" href="dir_5f09ffc654cb74a36b76a99b4e5ca3e7.html">Design</a></li><li class="navelem"><a class="el" href="dir_b35860c835ebf4efaf371ebd7d0fb965.html">SW</a></li><li class="navelem"><a class="el" href="dir_3b9fde39f5c0c05cff50c7bc821c5939.html">RO_firmware_v1.X</a></li><li class="navelem"><a class="el" href="dir_36150de6f2b4bab4ac56ee3a1d2e4e4b.html">mcc_generated_files</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">i2c1.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;xc.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for i2c1.h:</div>
<div class="dyncontent">
<div class="center"><img src="i2c1_8h__incl.png" border="0" usemap="#a_c_1_2_users_2_e_d_u___o_b_o_s__5057_2_documents_2_reflow_01oven_2_design_2_s_w_2_r_o__firmware__v1_8_x_2mcc__generated__files_2i2c1_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="i2c1_8h__dep__incl.png" border="0" usemap="#a_c_1_2_users_2_e_d_u___o_b_o_s__5057_2_documents_2_reflow_01oven_2_design_2_s_w_2_r_o__firmware__v1_8_x_2mcc__generated__files_2i2c1_8hdep" alt=""/></div>
</div>
</div>
<p><a href="i2c1_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k.html">I2C1_TRANSACTION_REQUEST_BLOCK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3aa7471e380d7a4957f9a0eb726c6582"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582">I2C1_MESSAGE_STATUS</a> { <br />
&#160;&#160;<a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582a59ca3c181df953e21b33790315a81cb3">I2C1_MESSAGE_FAIL</a>
, <a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582a2fe442fd94e8303f3e766861256ad046">I2C1_MESSAGE_PENDING</a>
, <a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582a4cae0cd4182ead73a74af82864de08bf">I2C1_MESSAGE_COMPLETE</a>
, <a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582a4e33d83279027e36db53031533678bbf">I2C1_STUCK_START</a>
, <br />
&#160;&#160;<a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582a6a0eb4274a65f90ebd90828451a5af98">I2C1_MESSAGE_ADDRESS_NO_ACK</a>
, <a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582af95297b81b88ff5a338f136c01bd090e">I2C1_DATA_NO_ACK</a>
, <a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582ab7d7cb09234ce24bb1233fdbf7ce26ef">I2C1_LOST_STATE</a>
<br />
 }</td></tr>
<tr class="separator:a3aa7471e380d7a4957f9a0eb726c6582"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0d2688c99f12f3c79e9867b3f48a4b70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c1_8h.html#a0d2688c99f12f3c79e9867b3f48a4b70">I2C1_Initialize</a> (void)</td></tr>
<tr class="separator:a0d2688c99f12f3c79e9867b3f48a4b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c5623a0a38d361ec389aba34921822"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c1_8h.html#ac1c5623a0a38d361ec389aba34921822">I2C1_MasterWrite</a> (uint8_t *pdata, uint8_t length, uint16_t address, <a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582">I2C1_MESSAGE_STATUS</a> *pstatus)</td></tr>
<tr class="separator:ac1c5623a0a38d361ec389aba34921822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80893177a8cb40f7c30c9932bc5e8006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c1_8h.html#a80893177a8cb40f7c30c9932bc5e8006">I2C1_MasterRead</a> (uint8_t *pdata, uint8_t length, uint16_t address, <a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582">I2C1_MESSAGE_STATUS</a> *pstatus)</td></tr>
<tr class="separator:a80893177a8cb40f7c30c9932bc5e8006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860d0c61c4bfa0434f345692cd277328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c1_8h.html#a860d0c61c4bfa0434f345692cd277328">I2C1_MasterTRBInsert</a> (uint8_t count, <a class="el" href="struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k.html">I2C1_TRANSACTION_REQUEST_BLOCK</a> *ptrb_list, <a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582">I2C1_MESSAGE_STATUS</a> *pflag)</td></tr>
<tr class="separator:a860d0c61c4bfa0434f345692cd277328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92070148034b505be5339108b9f449d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c1_8h.html#a92070148034b505be5339108b9f449d0">I2C1_MasterReadTRBBuild</a> (<a class="el" href="struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k.html">I2C1_TRANSACTION_REQUEST_BLOCK</a> *ptrb, uint8_t *pdata, uint8_t length, uint16_t address)</td></tr>
<tr class="separator:a92070148034b505be5339108b9f449d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec0129336e0fcb629eeb55210707c2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c1_8h.html#a0ec0129336e0fcb629eeb55210707c2d">I2C1_MasterWriteTRBBuild</a> (<a class="el" href="struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k.html">I2C1_TRANSACTION_REQUEST_BLOCK</a> *ptrb, uint8_t *pdata, uint8_t length, uint16_t address)</td></tr>
<tr class="separator:a0ec0129336e0fcb629eeb55210707c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707a253166a254c3ddd39f3f6c111728"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c1_8h.html#a707a253166a254c3ddd39f3f6c111728">I2C1_MasterQueueIsEmpty</a> (void)</td></tr>
<tr class="separator:a707a253166a254c3ddd39f3f6c111728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dead192d1f64473cc539c69695612a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c1_8h.html#a0dead192d1f64473cc539c69695612a1">I2C1_MasterQueueIsFull</a> (void)</td></tr>
<tr class="separator:a0dead192d1f64473cc539c69695612a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a3aa7471e380d7a4957f9a0eb726c6582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa7471e380d7a4957f9a0eb726c6582">&#9670;&nbsp;</a></span>I2C1_MESSAGE_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582">I2C1_MESSAGE_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C1 Generated Driver API Header File</p>
<p>@Company Microchip Technology Inc.</p>
<p>@File Name <a class="el" href="i2c1_8h.html">i2c1.h</a></p>
<p>@Summary This is the generated header file for the I2C1 driver using PIC24 / dsPIC33 / PIC32MM MCUs</p>
<p>@Description This header file provides APIs for driver for I2C1. Generation Information : Product Revision : PIC24 / dsPIC33 / PIC32MM MCUs - 1.170.0 Device : PIC24FJ256GA702</p>
<p>The generated drivers are tested against the following: Compiler : XC16 v1.61 MPLAB : MPLAB X v5.45 Section: Included Files Section: Data Type Definitions I2C Driver Message Status Type Enumeration</p>
<p>@Summary Defines the different message status when processing TRBs.</p>
<p>@Description This type enumeration specifies the different types of status that an i2c request will have. For every submission of an i2c transaction, the status of that transaction is available. Based on the status, new transactions can be requested to the driver or a recovery can be performed to resend the transaction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3aa7471e380d7a4957f9a0eb726c6582a59ca3c181df953e21b33790315a81cb3"></a>I2C1_MESSAGE_FAIL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3aa7471e380d7a4957f9a0eb726c6582a2fe442fd94e8303f3e766861256ad046"></a>I2C1_MESSAGE_PENDING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3aa7471e380d7a4957f9a0eb726c6582a4cae0cd4182ead73a74af82864de08bf"></a>I2C1_MESSAGE_COMPLETE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3aa7471e380d7a4957f9a0eb726c6582a4e33d83279027e36db53031533678bbf"></a>I2C1_STUCK_START&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3aa7471e380d7a4957f9a0eb726c6582a6a0eb4274a65f90ebd90828451a5af98"></a>I2C1_MESSAGE_ADDRESS_NO_ACK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3aa7471e380d7a4957f9a0eb726c6582af95297b81b88ff5a338f136c01bd090e"></a>I2C1_DATA_NO_ACK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3aa7471e380d7a4957f9a0eb726c6582ab7d7cb09234ce24bb1233fdbf7ce26ef"></a>I2C1_LOST_STATE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c1_8h_source.html#l00084">84</a> of file <a class="el" href="i2c1_8h_source.html">i2c1.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0d2688c99f12f3c79e9867b3f48a4b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2688c99f12f3c79e9867b3f48a4b70">&#9670;&nbsp;</a></span>I2C1_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_Initialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Section: Interface Routines @Summary Initializes the I2C instance : 1</p>
<p>@Description This routine initializes the i2c1 driver instance for : 1 index, making it ready for clients to open and use it. This routine must be called before any other I2C1 routine is called. This routine should only be called once during system initialization.</p>
<p>@Preconditions None.</p>
<p>@Param None.</p>
<p>@Returns None.</p>
<p>@Example <code> #define SLAVE_I2C_GENERIC_RETRY_MAX 100 #define SLAVE_I2C_GENERIC_DEVICE_TIMEOUT 50 // define slave timeout</code></p>
<p><code>initialize the module <a class="el" href="i2c1_8c.html#a0d2688c99f12f3c79e9867b3f48a4b70">I2C1_Initialize()</a>;</code></p>
<p><code>write to an EEPROM Device </p><pre class="fragment">    uint16_t        dataAddress;
    uint8_t         sourceData[16] = {  0xA0, 0xA1, 0xA2, 0xA3, 
                                        0xA4, 0xA5, 0xA6, 0xA7, 
                                        0xA8, 0xA9, 0xAA, 0xAB, 
                                        0xAC, 0xAD, 0xAE, 0xAF }; 
    uint8_t         *pData;
    uint16_t        nCount;

    uint8_t         writeBuffer[3];
    uint8_t         *pD;
    uint16_t        counter, timeOut, slaveTimeOut;

    I2C1_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;

    dataAddress = 0x10;             // starting EEPROM address 
    pD = sourceData;                // initialize the source of the data
    nCount = 16;                    // number of bytes to write

    for (counter = 0; counter &lt; nCount; counter++)
    {
</pre><p> build the write buffer first starting address of the EEPROM memory writeBuffer[0] = (dataAddress &gt;&gt; 8); // high address writeBuffer[1] = (uint8_t)(dataAddress); // low low address</code></p>
<p><code>data to be written writeBuffer[2] = *pD++;</code></p>
<p><code>Now it is possible that the slave device will be slow. As a work around on these slaves, the application can retry sending the transaction timeOut = 0; slaveTimeOut = 0;</code></p>
<p><code> while(status != I2C1_MESSAGE_FAIL) { write one byte to EEPROM (3 is the number of bytes to write) I2C1_MasterWrite( writeBuffer, 3, slaveDeviceAddress, &amp;status);</code></p>
<p><code>wait for the message to be sent or status has changed. while(status == I2C1_MESSAGE_PENDING) { add some delay here</code></p>
<p><code>timeout checking check for max retry and skip this byte if (slaveTimeOut == SLAVE_I2C_GENERIC_DEVICE_TIMEOUT) break; else slaveTimeOut++; } if ((slaveTimeOut == SLAVE_I2C_GENERIC_DEVICE_TIMEOUT) || (status == I2C1_MESSAGE_COMPLETE)) break;</code></p>
<p><code>if status is I2C1_MESSAGE_ADDRESS_NO_ACK, or I2C1_DATA_NO_ACK, The device may be busy and needs more time for the last write so we can retry writing the data, this is why we use a while loop here</code></p>
<p><code>check for max retry and skip this byte if (timeOut == SLAVE_I2C_GENERIC_RETRY_MAX) break; else timeOut++; }</code></p>
<p><code> if (status == I2C1_MESSAGE_FAIL) { break; } dataAddress++;</code></p>
<p><code> }</code></p>
<p><code> </code></p>
<p>Section: Driver Interface </p>

<p class="definition">Definition at line <a class="el" href="i2c1_8c_source.html#l00196">196</a> of file <a class="el" href="i2c1_8c_source.html">i2c1.c</a>.</p>

</div>
</div>
<a id="a707a253166a254c3ddd39f3f6c111728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707a253166a254c3ddd39f3f6c111728">&#9670;&nbsp;</a></span>I2C1_MasterQueueIsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C1_MasterQueueIsEmpty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">@Summary
    This function returns the empty status of the Master
    queue.

@Description
    This function returns the empty status of the Master
    queue. Use this function to check if the queue is empty.
    This can verify if the Master is currently idle.

@Preconditions
    None

@Param
    None

@Returns
    True if the queue is empty and false if the queue is not empty.

@Example
    &lt;code&gt;
        #define MCHP24AA512_ADDRESS    0x50 // slave device address
</pre><p> check until queue is empty while(<a class="el" href="i2c1_8h.html#a707a253166a254c3ddd39f3f6c111728">I2C1_MasterQueueIsEmpty()</a> == false);</p>
<p>now send more data (assume readBuffer is initialized) I2C1_MasterRead( readBuffer, 3, MCHP24AA512_ADDRESS, &amp;status); <br  />
</p>

<p class="definition">Definition at line <a class="el" href="i2c1_8c_source.html#l00707">707</a> of file <a class="el" href="i2c1_8c_source.html">i2c1.c</a>.</p>

</div>
</div>
<a id="a0dead192d1f64473cc539c69695612a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dead192d1f64473cc539c69695612a1">&#9670;&nbsp;</a></span>I2C1_MasterQueueIsFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C1_MasterQueueIsFull </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">@Summary
    This function returns the full status of the Master
    queue.

@Description
    This function returns the full status of the Master
    queue. Use this function to check if the queue is full.
    This can verify if the Master will not be able to accept
    addition transactions.

@Preconditions
    None

@Param
    None

@Returns
    True if the queue is full and false if the queue is not full.

@Example
    &lt;code&gt;
        #define MCHP24AA512_ADDRESS    0x50 // slave device address
</pre><p> check until queue has space while(<a class="el" href="i2c1_8h.html#a0dead192d1f64473cc539c69695612a1">I2C1_MasterQueueIsFull()</a> == true);</p>
<p>now send more data (assume readBuffer is initialized) I2C1_MasterRead( readBuffer, 3, MCHP24AA512_ADDRESS, &amp;status);  </p>

<p class="definition">Definition at line <a class="el" href="i2c1_8c_source.html#l00712">712</a> of file <a class="el" href="i2c1_8c_source.html">i2c1.c</a>.</p>

</div>
</div>
<a id="a80893177a8cb40f7c30c9932bc5e8006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80893177a8cb40f7c30c9932bc5e8006">&#9670;&nbsp;</a></span>I2C1_MasterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_MasterRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582">I2C1_MESSAGE_STATUS</a> *&#160;</td>
          <td class="paramname"><em>pstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">@Summary
    Handles one i2c master read transaction with the
    supplied parameters.

@Description
    This function prepares a TRB, then inserts it on the i2c queue.
    Finally, it waits for the transaction to complete and returns
    the result.

@Preconditions
    None

@Param
    address - The address of the i2c peripheral to be accessed

@Param
    length - The length of the data block to be sent

@Param
     pdata - A pointer to the memory location where received data will
             be stored

@Param
     pstatus - A pointer to the status variable that the i2c driver
        updates during the execution of the message.

@Returns
    I2C1_MESSAGE_STATUS

@Example
    &lt;code&gt;

        #define MCHP24AA512_RETRY_MAX       100  // define the retry count
        #define MCHP24AA512_ADDRESS         0x50 // slave device address
        #define MCHP24AA512_DEVICE_TIMEOUT  50   // define slave timeout 


        uint8_t MCHP24AA512_Read(
                                        uint16_t address,
                                        uint8_t *pData,
                                        uint16_t nCount)
        {
            I2C1_MESSAGE_STATUS status;
            uint8_t     writeBuffer[3];
            uint16_t    retryTimeOut, slaveTimeOut;
            uint16_t    counter;
            uint8_t     *pD;

            pD = pData;

            for (counter = 0; counter &lt; nCount; counter++)
            {
</pre><p> build the write buffer first starting address of the EEPROM memory writeBuffer[0] = (address &gt;&gt; 8); // high address writeBuffer[1] = (uint8_t)(address); // low low address</p>
<p>Now it is possible that the slave device will be slow. As a work around on these slaves, the application can retry sending the transaction retryTimeOut = 0; slaveTimeOut = 0;</p>
<p>while(status != I2C1_MESSAGE_FAIL) { write one byte to EEPROM (2 is the count of bytes to write) I2C1_MasterWrite( writeBuffer, 2, MCHP24AA512_ADDRESS, &amp;status);</p>
<p>wait for the message to be sent or status has changed. while(status == I2C1_MESSAGE_PENDING) { add some delay here</p>
<p>timeout checking check for max retry and skip this byte if (slaveTimeOut == MCHP24AA512_DEVICE_TIMEOUT) return (0); else slaveTimeOut++; }</p>
<p>if (status == I2C1_MESSAGE_COMPLETE) break;</p>
<p>if status is I2C1_MESSAGE_ADDRESS_NO_ACK, or I2C1_DATA_NO_ACK, The device may be busy and needs more time for the last write so we can retry writing the data, this is why we use a while loop here</p>
<p>check for max retry and skip this byte if (retryTimeOut == MCHP24AA512_RETRY_MAX) break; else retryTimeOut++; }</p>
<p>if (status == I2C1_MESSAGE_COMPLETE) {</p>
<p>this portion will read the byte from the memory location. retryTimeOut = 0; slaveTimeOut = 0;</p>
<p>while(status != I2C1_MESSAGE_FAIL) { write one byte to EEPROM (2 is the count of bytes to write) I2C1_MasterRead( pD, 1, MCHP24AA512_ADDRESS, &amp;status);</p>
<p>wait for the message to be sent or status has changed. while(status == I2C1_MESSAGE_PENDING) { add some delay here</p>
<p>timeout checking check for max retry and skip this byte if (slaveTimeOut == MCHP24AA512_DEVICE_TIMEOUT) return (0); else slaveTimeOut++; }</p>
<p>if (status == I2C1_MESSAGE_COMPLETE) break;</p>
<p>if status is I2C1_MESSAGE_ADDRESS_NO_ACK, or I2C1_DATA_NO_ACK, The device may be busy and needs more time for the last write so we can retry writing the data, this is why we use a while loop here</p>
<p>check for max retry and skip this byte if (retryTimeOut == MCHP24AA512_RETRY_MAX) break; else retryTimeOut++; } }</p>
<p>exit if the last transaction failed if (status == I2C1_MESSAGE_FAIL) { return(0); break; }</p>
<p>pD++; address++;</p>
<p>} return(1);</p>
<p>}</p>
<pre class="fragment"> &lt;/code&gt;
</pre> 
<p class="definition">Definition at line <a class="el" href="i2c1_8c_source.html#l00611">611</a> of file <a class="el" href="i2c1_8c_source.html">i2c1.c</a>.</p>

</div>
</div>
<a id="a92070148034b505be5339108b9f449d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92070148034b505be5339108b9f449d0">&#9670;&nbsp;</a></span>I2C1_MasterReadTRBBuild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_MasterReadTRBBuild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k.html">I2C1_TRANSACTION_REQUEST_BLOCK</a> *&#160;</td>
          <td class="paramname"><em>ptrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@Summary This function populates a trb supplied by the calling function with the parameters supplied by the calling function.</p>
<p>@Description All i2c requests are in the form of TRB's. This helper function takes standard parameters and correctly formats the TRB. The R/W bit is set to ensure that the resulting TRB describes an i2c read operation.</p>
<p>This function does not send the transaction. To send the transaction, the TRB insert function (<a class="el" href="i2c1_8h.html#a860d0c61c4bfa0434f345692cd277328">I2C1_MasterTRBInsert()</a>) must be called.</p>
<p>@Preconditions None</p>
<p>@Param ptrb - A pointer to a caller supplied TRB.</p>
<p>@Param pdata - A pointer to the block of data to be received</p>
<p>@Param length - The length of the data block to be received</p>
<p>@Param address - The address of the i2c peripheral to be accessed</p>
<p>@Returns None</p>
<p>@Example <code> Refer to <a class="el" href="i2c1_8h.html#a860d0c61c4bfa0434f345692cd277328">I2C1_MasterTRBInsert()</a> for an example <br  />
 </code> </p>

<p class="definition">Definition at line <a class="el" href="i2c1_8c_source.html#l00683">683</a> of file <a class="el" href="i2c1_8c_source.html">i2c1.c</a>.</p>

</div>
</div>
<a id="a860d0c61c4bfa0434f345692cd277328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860d0c61c4bfa0434f345692cd277328">&#9670;&nbsp;</a></span>I2C1_MasterTRBInsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_MasterTRBInsert </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k.html">I2C1_TRANSACTION_REQUEST_BLOCK</a> *&#160;</td>
          <td class="paramname"><em>ptrb_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582">I2C1_MESSAGE_STATUS</a> *&#160;</td>
          <td class="paramname"><em>pflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">@Summary
    Inserts a list of i2c transaction requests into the i2c
    transaction queue.

@Description
    The i2c processes lists of transaction requests.  Each transaction
    list is handled as a string of i2c restarts.  When the list of
    transactions is complete, an i2c stop is produced, the flag is set
    with the correct condition code and the next list is processed
    from the queue.

    This function inserts lists of requests prepared by the user
    application into the queue along with a pointer to the completion
    flag.

    The transaction is inserted into the list only if there is space
    in the list. If there is no space, the function exits with the
    flag set to I2C1_MESSAGE_FAIL.

@Preconditions
    None

@Param
    count - The numer of transaction requests in the trb_list.

@Param
     ptrb_list - A pointer to an array of transaction requests (TRB).
        See I2C1_TRANSACTION_REQUEST_BLOCK definition for details.

@Param
     pflag - A pointer to a completion flag.

@Returns
    None

@Example
    &lt;code&gt;


        uint8_t EMULATED_EEPROM_Read(
                                       uint16_t slaveDeviceAddress,
                                       uint16_t dataAddress,
                                       uint8_t *pData,
                                       uint16_t nCount)
        {
            I2C1_MESSAGE_STATUS status;
            I2C1_TRANSACTION_REQUEST_BLOCK readTRB[2];
            uint8_t     writeBuffer[3];
            uint16_t    timeOut, slaveTimeOut;
</pre><p> this initial value is important status = I2C1_MESSAGE_PENDING;</p>
<p>build the write buffer first starting address of the EEPROM memory writeBuffer[0] = (dataAddress &gt;&gt; 8); // high address writeBuffer[1] = (uint8_t)(dataAddress); // low low address</p>
<p>we need to create the TRBs for a random read sequence to the EEPROM Build TRB for sending address I2C1_MasterWriteTRBBuild( &amp;readTRB[0], writeBuffer, 2, slaveDeviceAddress); Build TRB for receiving data I2C1_MasterReadTRBBuild( &amp;readTRB[1], pData, nCount, slaveDeviceAddress);</p>
<p>timeOut = 0; slaveTimeOut = 0;</p>
<p>while(status != I2C1_MESSAGE_FAIL) { now send the transactions I2C1_MasterTRBInsert(2, readTRB, &amp;status);</p>
<p>wait for the message to be sent or status has changed. while(status == I2C1_MESSAGE_PENDING) { add some delay here</p>
<p>timeout checking check for max retry and skip this byte if (slaveTimeOut == SLAVE_I2C_GENERIC_SLAVE_TIMEOUT) return (0); else slaveTimeOut++; }</p>
<p>if (status == I2C1_MESSAGE_COMPLETE) break;</p>
<p>if status is I2C1_MESSAGE_ADDRESS_NO_ACK, or I2C1_DATA_NO_ACK, The device may be busy and needs more time for the last write so we can retry writing the data, this is why we use a while loop here</p>
<p>check for max retry and skip this byte if (timeOut == SLAVE_I2C_GENERIC_RETRY_MAX) return (0); else timeOut++;</p>
<p>} return (1);</p>
<p>} <br  />
</p>

<p class="definition">Definition at line <a class="el" href="i2c1_8c_source.html#l00633">633</a> of file <a class="el" href="i2c1_8c_source.html">i2c1.c</a>.</p>

</div>
</div>
<a id="ac1c5623a0a38d361ec389aba34921822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c5623a0a38d361ec389aba34921822">&#9670;&nbsp;</a></span>I2C1_MasterWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_MasterWrite </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="i2c1_8h.html#a3aa7471e380d7a4957f9a0eb726c6582">I2C1_MESSAGE_STATUS</a> *&#160;</td>
          <td class="paramname"><em>pstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@Summary Handles one i2c master write transaction with the supplied parameters.</p>
<p>@Description This function prepares a TRB, then inserts it on the i2c queue. Finally, it waits for the transaction to complete and returns the result.</p>
<p>@Preconditions None</p>
<p>@Param address - The address of the i2c peripheral to be accessed</p>
<p>@Param length - The length of the data block to be sent</p>
<p>@Param pdata - A pointer to the block of data to be sent</p>
<p>@Param pstatus - A pointer to the status variable that the i2c driver updates during the execution of the message.</p>
<p>@Returns I2C1_MESSAGE_STATUS</p>
<p>@Example <code> Refer to <a class="el" href="i2c1_8h.html#a0d2688c99f12f3c79e9867b3f48a4b70">I2C1_Initialize()</a> and <a class="el" href="i2c1_8h.html#a80893177a8cb40f7c30c9932bc5e8006">I2C1_MasterRead()</a> for an examples <br  />
 </code> </p>

<p class="definition">Definition at line <a class="el" href="i2c1_8c_source.html#l00590">590</a> of file <a class="el" href="i2c1_8c_source.html">i2c1.c</a>.</p>

</div>
</div>
<a id="a0ec0129336e0fcb629eeb55210707c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec0129336e0fcb629eeb55210707c2d">&#9670;&nbsp;</a></span>I2C1_MasterWriteTRBBuild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_MasterWriteTRBBuild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k.html">I2C1_TRANSACTION_REQUEST_BLOCK</a> *&#160;</td>
          <td class="paramname"><em>ptrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@Summary This function populates a trb supplied by the calling function with the parameters supplied by the calling function.</p>
<p>@Description All i2c requests are in the form of TRB's. This helper function takes standard parameters and correctly formats the TRB. The R/W bit is cleared to ensure that the resulting TRB describes an i2c write operation.</p>
<p>This function does not send the transaction. To send the transaction, the TRB insert function (<a class="el" href="i2c1_8h.html#a860d0c61c4bfa0434f345692cd277328">I2C1_MasterTRBInsert()</a>) must be called.</p>
<p>@Preconditions None</p>
<p>@Param ptrb - A pointer to a caller supplied TRB.</p>
<p>@Param pdata - A pointer to the block of data to be sent</p>
<p>@Param length - The length of the data block to be sent</p>
<p>@Param address - The address of the i2c peripheral to be accessed</p>
<p>@Returns None</p>
<p>@Example <code> Refer to <a class="el" href="i2c1_8h.html#a860d0c61c4bfa0434f345692cd277328">I2C1_MasterTRBInsert()</a> for an example <br  />
 </code> </p>

<p class="definition">Definition at line <a class="el" href="i2c1_8c_source.html#l00696">696</a> of file <a class="el" href="i2c1_8c_source.html">i2c1.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
