\hypertarget{i2c1_8h}{}\doxysection{C\+:/\+Users/\+EDU\+\_\+\+OBOS\+\_\+5057/\+Documents/\+Reflow oven/\+Design/\+SW/\+RO\+\_\+firmware\+\_\+v1.X/mcc\+\_\+generated\+\_\+files/i2c1.h File Reference}
\label{i2c1_8h}\index{C:/Users/EDU\_OBOS\_5057/Documents/Reflow oven/Design/SW/RO\_firmware\_v1.X/mcc\_generated\_files/i2c1.h@{C:/Users/EDU\_OBOS\_5057/Documents/Reflow oven/Design/SW/RO\_firmware\_v1.X/mcc\_generated\_files/i2c1.h}}
{\ttfamily \#include $<$stdint.\+h$>$}\newline
{\ttfamily \#include $<$stdbool.\+h$>$}\newline
{\ttfamily \#include $<$stddef.\+h$>$}\newline
{\ttfamily \#include $<$xc.\+h$>$}\newline
Include dependency graph for i2c1.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\doxysubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k}{I2\+C1\+\_\+\+TRANSACTION\+\_\+\+REQUEST\+\_\+\+BLOCK}}
\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+STATUS}} \{ \newline
\mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a59ca3c181df953e21b33790315a81cb3}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+FAIL}}
, \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a2fe442fd94e8303f3e766861256ad046}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+PENDING}}
, \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a4cae0cd4182ead73a74af82864de08bf}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+COMPLETE}}
, \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a4e33d83279027e36db53031533678bbf}{I2\+C1\+\_\+\+STUCK\+\_\+\+START}}
, \newline
\mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a6a0eb4274a65f90ebd90828451a5af98}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+ADDRESS\+\_\+\+NO\+\_\+\+ACK}}
, \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582af95297b81b88ff5a338f136c01bd090e}{I2\+C1\+\_\+\+DATA\+\_\+\+NO\+\_\+\+ACK}}
, \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582ab7d7cb09234ce24bb1233fdbf7ce26ef}{I2\+C1\+\_\+\+LOST\+\_\+\+STATE}}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{i2c1_8h_a0d2688c99f12f3c79e9867b3f48a4b70}{I2\+C1\+\_\+\+Initialize}} (void)
\item 
void \mbox{\hyperlink{i2c1_8h_ac1c5623a0a38d361ec389aba34921822}{I2\+C1\+\_\+\+Master\+Write}} (uint8\+\_\+t $\ast$pdata, uint8\+\_\+t length, uint16\+\_\+t address, \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+STATUS}} $\ast$pstatus)
\item 
void \mbox{\hyperlink{i2c1_8h_a80893177a8cb40f7c30c9932bc5e8006}{I2\+C1\+\_\+\+Master\+Read}} (uint8\+\_\+t $\ast$pdata, uint8\+\_\+t length, uint16\+\_\+t address, \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+STATUS}} $\ast$pstatus)
\item 
void \mbox{\hyperlink{i2c1_8h_a860d0c61c4bfa0434f345692cd277328}{I2\+C1\+\_\+\+Master\+TRBInsert}} (uint8\+\_\+t count, \mbox{\hyperlink{struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k}{I2\+C1\+\_\+\+TRANSACTION\+\_\+\+REQUEST\+\_\+\+BLOCK}} $\ast$ptrb\+\_\+list, \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+STATUS}} $\ast$pflag)
\item 
void \mbox{\hyperlink{i2c1_8h_a92070148034b505be5339108b9f449d0}{I2\+C1\+\_\+\+Master\+Read\+TRBBuild}} (\mbox{\hyperlink{struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k}{I2\+C1\+\_\+\+TRANSACTION\+\_\+\+REQUEST\+\_\+\+BLOCK}} $\ast$ptrb, uint8\+\_\+t $\ast$pdata, uint8\+\_\+t length, uint16\+\_\+t address)
\item 
void \mbox{\hyperlink{i2c1_8h_a0ec0129336e0fcb629eeb55210707c2d}{I2\+C1\+\_\+\+Master\+Write\+TRBBuild}} (\mbox{\hyperlink{struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k}{I2\+C1\+\_\+\+TRANSACTION\+\_\+\+REQUEST\+\_\+\+BLOCK}} $\ast$ptrb, uint8\+\_\+t $\ast$pdata, uint8\+\_\+t length, uint16\+\_\+t address)
\item 
bool \mbox{\hyperlink{i2c1_8h_a707a253166a254c3ddd39f3f6c111728}{I2\+C1\+\_\+\+Master\+Queue\+Is\+Empty}} (void)
\item 
bool \mbox{\hyperlink{i2c1_8h_a0dead192d1f64473cc539c69695612a1}{I2\+C1\+\_\+\+Master\+Queue\+Is\+Full}} (void)
\end{DoxyCompactItemize}


\doxysubsection{Enumeration Type Documentation}
\mbox{\Hypertarget{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}\label{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}} 
\index{i2c1.h@{i2c1.h}!I2C1\_MESSAGE\_STATUS@{I2C1\_MESSAGE\_STATUS}}
\index{I2C1\_MESSAGE\_STATUS@{I2C1\_MESSAGE\_STATUS}!i2c1.h@{i2c1.h}}
\doxysubsubsection{\texorpdfstring{I2C1\_MESSAGE\_STATUS}{I2C1\_MESSAGE\_STATUS}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+STATUS}}}

I2\+C1 Generated Driver API Header File

@\+Company Microchip Technology Inc.

@\+File Name \mbox{\hyperlink{i2c1_8h}{i2c1.\+h}}

@\+Summary This is the generated header file for the I2\+C1 driver using PIC24 / ds\+PIC33 / PIC32\+MM MCUs

@\+Description This header file provides APIs for driver for I2\+C1. Generation Information \+: Product Revision \+: PIC24 / ds\+PIC33 / PIC32\+MM MCUs -\/ 1.\+170.\+0 Device \+: PIC24\+FJ256\+GA702

The generated drivers are tested against the following\+: Compiler \+: XC16 v1.\+61 MPLAB \+: MPLAB X v5.\+45 Section\+: Included Files Section\+: Data Type Definitions I2C Driver Message Status Type Enumeration

@\+Summary Defines the different message status when processing TRBs.

@\+Description This type enumeration specifies the different types of status that an i2c request will have. For every submission of an i2c transaction, the status of that transaction is available. Based on the status, new transactions can be requested to the driver or a recovery can be performed to resend the transaction. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{I2C1\_MESSAGE\_FAIL@{I2C1\_MESSAGE\_FAIL}!i2c1.h@{i2c1.h}}\index{i2c1.h@{i2c1.h}!I2C1\_MESSAGE\_FAIL@{I2C1\_MESSAGE\_FAIL}}}\mbox{\Hypertarget{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a59ca3c181df953e21b33790315a81cb3}\label{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a59ca3c181df953e21b33790315a81cb3}} 
I2\+C1\+\_\+\+MESSAGE\+\_\+\+FAIL&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{I2C1\_MESSAGE\_PENDING@{I2C1\_MESSAGE\_PENDING}!i2c1.h@{i2c1.h}}\index{i2c1.h@{i2c1.h}!I2C1\_MESSAGE\_PENDING@{I2C1\_MESSAGE\_PENDING}}}\mbox{\Hypertarget{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a2fe442fd94e8303f3e766861256ad046}\label{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a2fe442fd94e8303f3e766861256ad046}} 
I2\+C1\+\_\+\+MESSAGE\+\_\+\+PENDING&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{I2C1\_MESSAGE\_COMPLETE@{I2C1\_MESSAGE\_COMPLETE}!i2c1.h@{i2c1.h}}\index{i2c1.h@{i2c1.h}!I2C1\_MESSAGE\_COMPLETE@{I2C1\_MESSAGE\_COMPLETE}}}\mbox{\Hypertarget{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a4cae0cd4182ead73a74af82864de08bf}\label{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a4cae0cd4182ead73a74af82864de08bf}} 
I2\+C1\+\_\+\+MESSAGE\+\_\+\+COMPLETE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{I2C1\_STUCK\_START@{I2C1\_STUCK\_START}!i2c1.h@{i2c1.h}}\index{i2c1.h@{i2c1.h}!I2C1\_STUCK\_START@{I2C1\_STUCK\_START}}}\mbox{\Hypertarget{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a4e33d83279027e36db53031533678bbf}\label{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a4e33d83279027e36db53031533678bbf}} 
I2\+C1\+\_\+\+STUCK\+\_\+\+START&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{I2C1\_MESSAGE\_ADDRESS\_NO\_ACK@{I2C1\_MESSAGE\_ADDRESS\_NO\_ACK}!i2c1.h@{i2c1.h}}\index{i2c1.h@{i2c1.h}!I2C1\_MESSAGE\_ADDRESS\_NO\_ACK@{I2C1\_MESSAGE\_ADDRESS\_NO\_ACK}}}\mbox{\Hypertarget{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a6a0eb4274a65f90ebd90828451a5af98}\label{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582a6a0eb4274a65f90ebd90828451a5af98}} 
I2\+C1\+\_\+\+MESSAGE\+\_\+\+ADDRESS\+\_\+\+NO\+\_\+\+ACK&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{I2C1\_DATA\_NO\_ACK@{I2C1\_DATA\_NO\_ACK}!i2c1.h@{i2c1.h}}\index{i2c1.h@{i2c1.h}!I2C1\_DATA\_NO\_ACK@{I2C1\_DATA\_NO\_ACK}}}\mbox{\Hypertarget{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582af95297b81b88ff5a338f136c01bd090e}\label{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582af95297b81b88ff5a338f136c01bd090e}} 
I2\+C1\+\_\+\+DATA\+\_\+\+NO\+\_\+\+ACK&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{I2C1\_LOST\_STATE@{I2C1\_LOST\_STATE}!i2c1.h@{i2c1.h}}\index{i2c1.h@{i2c1.h}!I2C1\_LOST\_STATE@{I2C1\_LOST\_STATE}}}\mbox{\Hypertarget{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582ab7d7cb09234ce24bb1233fdbf7ce26ef}\label{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582ab7d7cb09234ce24bb1233fdbf7ce26ef}} 
I2\+C1\+\_\+\+LOST\+\_\+\+STATE&\\
\hline

\end{DoxyEnumFields}


Definition at line 84 of file i2c1.\+h.



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{i2c1_8h_a0d2688c99f12f3c79e9867b3f48a4b70}\label{i2c1_8h_a0d2688c99f12f3c79e9867b3f48a4b70}} 
\index{i2c1.h@{i2c1.h}!I2C1\_Initialize@{I2C1\_Initialize}}
\index{I2C1\_Initialize@{I2C1\_Initialize}!i2c1.h@{i2c1.h}}
\doxysubsubsection{\texorpdfstring{I2C1\_Initialize()}{I2C1\_Initialize()}}
{\footnotesize\ttfamily void I2\+C1\+\_\+\+Initialize (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Section\+: Interface Routines @\+Summary Initializes the I2C instance \+: 1

@\+Description This routine initializes the i2c1 driver instance for \+: 1 index, making it ready for clients to open and use it. This routine must be called before any other I2\+C1 routine is called. This routine should only be called once during system initialization.

@\+Preconditions None.

@\+Param None.

@\+Returns None.

@\+Example {\ttfamily  \#define SLAVE\+\_\+\+I2\+C\+\_\+\+GENERIC\+\_\+\+RETRY\+\_\+\+MAX 100 \#define SLAVE\+\_\+\+I2\+C\+\_\+\+GENERIC\+\_\+\+DEVICE\+\_\+\+TIMEOUT 50 // define slave timeout}

{\ttfamily initialize the module \mbox{\hyperlink{i2c1_8c_a0d2688c99f12f3c79e9867b3f48a4b70}{I2\+C1\+\_\+\+Initialize()}};}

{\ttfamily write to an EEPROM Device \begin{DoxyVerb}    uint16_t        dataAddress;
    uint8_t         sourceData[16] = {  0xA0, 0xA1, 0xA2, 0xA3, 
                                        0xA4, 0xA5, 0xA6, 0xA7, 
                                        0xA8, 0xA9, 0xAA, 0xAB, 
                                        0xAC, 0xAD, 0xAE, 0xAF }; 
    uint8_t         *pData;
    uint16_t        nCount;

    uint8_t         writeBuffer[3];
    uint8_t         *pD;
    uint16_t        counter, timeOut, slaveTimeOut;

    I2C1_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;

    dataAddress = 0x10;             // starting EEPROM address 
    pD = sourceData;                // initialize the source of the data
    nCount = 16;                    // number of bytes to write

    for (counter = 0; counter < nCount; counter++)
    {
\end{DoxyVerb}
 build the write buffer first starting address of the EEPROM memory write\+Buffer\mbox{[}0\mbox{]} = (data\+Address $>$$>$ 8); // high address write\+Buffer\mbox{[}1\mbox{]} = (uint8\+\_\+t)(data\+Address); // low low address}

{\ttfamily data to be written write\+Buffer\mbox{[}2\mbox{]} = $\ast$p\+D++;}

{\ttfamily Now it is possible that the slave device will be slow. As a work around on these slaves, the application can retry sending the transaction time\+Out = 0; slave\+Time\+Out = 0;}

{\ttfamily  while(status != I2\+C1\+\_\+\+MESSAGE\+\_\+\+FAIL) \{ write one byte to EEPROM (3 is the number of bytes to write) I2\+C1\+\_\+\+Master\+Write( write\+Buffer, 3, slave\+Device\+Address, \&status);}

{\ttfamily wait for the message to be sent or status has changed. while(status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+PENDING) \{ add some delay here}

{\ttfamily timeout checking check for max retry and skip this byte if (slave\+Time\+Out == SLAVE\+\_\+\+I2\+C\+\_\+\+GENERIC\+\_\+\+DEVICE\+\_\+\+TIMEOUT) break; else slave\+Time\+Out++; \} if ((slave\+Time\+Out == SLAVE\+\_\+\+I2\+C\+\_\+\+GENERIC\+\_\+\+DEVICE\+\_\+\+TIMEOUT) $\vert$$\vert$ (status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+COMPLETE)) break;}

{\ttfamily if status is I2\+C1\+\_\+\+MESSAGE\+\_\+\+ADDRESS\+\_\+\+NO\+\_\+\+ACK, or I2\+C1\+\_\+\+DATA\+\_\+\+NO\+\_\+\+ACK, The device may be busy and needs more time for the last write so we can retry writing the data, this is why we use a while loop here}

{\ttfamily check for max retry and skip this byte if (time\+Out == SLAVE\+\_\+\+I2\+C\+\_\+\+GENERIC\+\_\+\+RETRY\+\_\+\+MAX) break; else time\+Out++; \}}

{\ttfamily  if (status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+FAIL) \{ break; \} data\+Address++;}

{\ttfamily  \}}

{\ttfamily  }

Section\+: Driver Interface 

Definition at line 196 of file i2c1.\+c.

\mbox{\Hypertarget{i2c1_8h_a707a253166a254c3ddd39f3f6c111728}\label{i2c1_8h_a707a253166a254c3ddd39f3f6c111728}} 
\index{i2c1.h@{i2c1.h}!I2C1\_MasterQueueIsEmpty@{I2C1\_MasterQueueIsEmpty}}
\index{I2C1\_MasterQueueIsEmpty@{I2C1\_MasterQueueIsEmpty}!i2c1.h@{i2c1.h}}
\doxysubsubsection{\texorpdfstring{I2C1\_MasterQueueIsEmpty()}{I2C1\_MasterQueueIsEmpty()}}
{\footnotesize\ttfamily bool I2\+C1\+\_\+\+Master\+Queue\+Is\+Empty (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}@Summary
    This function returns the empty status of the Master
    queue.

@Description
    This function returns the empty status of the Master
    queue. Use this function to check if the queue is empty.
    This can verify if the Master is currently idle.

@Preconditions
    None

@Param
    None

@Returns
    True if the queue is empty and false if the queue is not empty.

@Example
    <code>
        #define MCHP24AA512_ADDRESS    0x50 // slave device address
\end{DoxyVerb}
 check until queue is empty while(\mbox{\hyperlink{i2c1_8h_a707a253166a254c3ddd39f3f6c111728}{I2\+C1\+\_\+\+Master\+Queue\+Is\+Empty()}} == false);

now send more data (assume read\+Buffer is initialized) I2\+C1\+\_\+\+Master\+Read( read\+Buffer, 3, MCHP24\+AA512\+\_\+\+ADDRESS, \&status); ~\newline


Definition at line 707 of file i2c1.\+c.

\mbox{\Hypertarget{i2c1_8h_a0dead192d1f64473cc539c69695612a1}\label{i2c1_8h_a0dead192d1f64473cc539c69695612a1}} 
\index{i2c1.h@{i2c1.h}!I2C1\_MasterQueueIsFull@{I2C1\_MasterQueueIsFull}}
\index{I2C1\_MasterQueueIsFull@{I2C1\_MasterQueueIsFull}!i2c1.h@{i2c1.h}}
\doxysubsubsection{\texorpdfstring{I2C1\_MasterQueueIsFull()}{I2C1\_MasterQueueIsFull()}}
{\footnotesize\ttfamily bool I2\+C1\+\_\+\+Master\+Queue\+Is\+Full (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}@Summary
    This function returns the full status of the Master
    queue.

@Description
    This function returns the full status of the Master
    queue. Use this function to check if the queue is full.
    This can verify if the Master will not be able to accept
    addition transactions.

@Preconditions
    None

@Param
    None

@Returns
    True if the queue is full and false if the queue is not full.

@Example
    <code>
        #define MCHP24AA512_ADDRESS    0x50 // slave device address
\end{DoxyVerb}
 check until queue has space while(\mbox{\hyperlink{i2c1_8h_a0dead192d1f64473cc539c69695612a1}{I2\+C1\+\_\+\+Master\+Queue\+Is\+Full()}} == true);

now send more data (assume read\+Buffer is initialized) I2\+C1\+\_\+\+Master\+Read( read\+Buffer, 3, MCHP24\+AA512\+\_\+\+ADDRESS, \&status);  

Definition at line 712 of file i2c1.\+c.

\mbox{\Hypertarget{i2c1_8h_a80893177a8cb40f7c30c9932bc5e8006}\label{i2c1_8h_a80893177a8cb40f7c30c9932bc5e8006}} 
\index{i2c1.h@{i2c1.h}!I2C1\_MasterRead@{I2C1\_MasterRead}}
\index{I2C1\_MasterRead@{I2C1\_MasterRead}!i2c1.h@{i2c1.h}}
\doxysubsubsection{\texorpdfstring{I2C1\_MasterRead()}{I2C1\_MasterRead()}}
{\footnotesize\ttfamily void I2\+C1\+\_\+\+Master\+Read (\begin{DoxyParamCaption}\item[{uint8\+\_\+t $\ast$}]{pdata,  }\item[{uint8\+\_\+t}]{length,  }\item[{uint16\+\_\+t}]{address,  }\item[{\mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+STATUS}} $\ast$}]{pstatus }\end{DoxyParamCaption})}

\begin{DoxyVerb}@Summary
    Handles one i2c master read transaction with the
    supplied parameters.

@Description
    This function prepares a TRB, then inserts it on the i2c queue.
    Finally, it waits for the transaction to complete and returns
    the result.

@Preconditions
    None

@Param
    address - The address of the i2c peripheral to be accessed

@Param
    length - The length of the data block to be sent

@Param
     pdata - A pointer to the memory location where received data will
             be stored

@Param
     pstatus - A pointer to the status variable that the i2c driver
        updates during the execution of the message.

@Returns
    I2C1_MESSAGE_STATUS

@Example
    <code>

        #define MCHP24AA512_RETRY_MAX       100  // define the retry count
        #define MCHP24AA512_ADDRESS         0x50 // slave device address
        #define MCHP24AA512_DEVICE_TIMEOUT  50   // define slave timeout 


        uint8_t MCHP24AA512_Read(
                                        uint16_t address,
                                        uint8_t *pData,
                                        uint16_t nCount)
        {
            I2C1_MESSAGE_STATUS status;
            uint8_t     writeBuffer[3];
            uint16_t    retryTimeOut, slaveTimeOut;
            uint16_t    counter;
            uint8_t     *pD;

            pD = pData;

            for (counter = 0; counter < nCount; counter++)
            {
\end{DoxyVerb}
 build the write buffer first starting address of the EEPROM memory write\+Buffer\mbox{[}0\mbox{]} = (address $>$$>$ 8); // high address write\+Buffer\mbox{[}1\mbox{]} = (uint8\+\_\+t)(address); // low low address

Now it is possible that the slave device will be slow. As a work around on these slaves, the application can retry sending the transaction retry\+Time\+Out = 0; slave\+Time\+Out = 0;

while(status != I2\+C1\+\_\+\+MESSAGE\+\_\+\+FAIL) \{ write one byte to EEPROM (2 is the count of bytes to write) I2\+C1\+\_\+\+Master\+Write( write\+Buffer, 2, MCHP24\+AA512\+\_\+\+ADDRESS, \&status);

wait for the message to be sent or status has changed. while(status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+PENDING) \{ add some delay here

timeout checking check for max retry and skip this byte if (slave\+Time\+Out == MCHP24\+AA512\+\_\+\+DEVICE\+\_\+\+TIMEOUT) return (0); else slave\+Time\+Out++; \}

if (status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+COMPLETE) break;

if status is I2\+C1\+\_\+\+MESSAGE\+\_\+\+ADDRESS\+\_\+\+NO\+\_\+\+ACK, or I2\+C1\+\_\+\+DATA\+\_\+\+NO\+\_\+\+ACK, The device may be busy and needs more time for the last write so we can retry writing the data, this is why we use a while loop here

check for max retry and skip this byte if (retry\+Time\+Out == MCHP24\+AA512\+\_\+\+RETRY\+\_\+\+MAX) break; else retry\+Time\+Out++; \}

if (status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+COMPLETE) \{

this portion will read the byte from the memory location. retry\+Time\+Out = 0; slave\+Time\+Out = 0;

while(status != I2\+C1\+\_\+\+MESSAGE\+\_\+\+FAIL) \{ write one byte to EEPROM (2 is the count of bytes to write) I2\+C1\+\_\+\+Master\+Read( pD, 1, MCHP24\+AA512\+\_\+\+ADDRESS, \&status);

wait for the message to be sent or status has changed. while(status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+PENDING) \{ add some delay here

timeout checking check for max retry and skip this byte if (slave\+Time\+Out == MCHP24\+AA512\+\_\+\+DEVICE\+\_\+\+TIMEOUT) return (0); else slave\+Time\+Out++; \}

if (status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+COMPLETE) break;

if status is I2\+C1\+\_\+\+MESSAGE\+\_\+\+ADDRESS\+\_\+\+NO\+\_\+\+ACK, or I2\+C1\+\_\+\+DATA\+\_\+\+NO\+\_\+\+ACK, The device may be busy and needs more time for the last write so we can retry writing the data, this is why we use a while loop here

check for max retry and skip this byte if (retry\+Time\+Out == MCHP24\+AA512\+\_\+\+RETRY\+\_\+\+MAX) break; else retry\+Time\+Out++; \} \}

exit if the last transaction failed if (status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+FAIL) \{ return(0); break; \}

p\+D++; address++;

\} return(1);

\}

\begin{DoxyVerb} </code>
\end{DoxyVerb}
 

Definition at line 611 of file i2c1.\+c.

\mbox{\Hypertarget{i2c1_8h_a92070148034b505be5339108b9f449d0}\label{i2c1_8h_a92070148034b505be5339108b9f449d0}} 
\index{i2c1.h@{i2c1.h}!I2C1\_MasterReadTRBBuild@{I2C1\_MasterReadTRBBuild}}
\index{I2C1\_MasterReadTRBBuild@{I2C1\_MasterReadTRBBuild}!i2c1.h@{i2c1.h}}
\doxysubsubsection{\texorpdfstring{I2C1\_MasterReadTRBBuild()}{I2C1\_MasterReadTRBBuild()}}
{\footnotesize\ttfamily void I2\+C1\+\_\+\+Master\+Read\+TRBBuild (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k}{I2\+C1\+\_\+\+TRANSACTION\+\_\+\+REQUEST\+\_\+\+BLOCK}} $\ast$}]{ptrb,  }\item[{uint8\+\_\+t $\ast$}]{pdata,  }\item[{uint8\+\_\+t}]{length,  }\item[{uint16\+\_\+t}]{address }\end{DoxyParamCaption})}

@\+Summary This function populates a trb supplied by the calling function with the parameters supplied by the calling function.

@\+Description All i2c requests are in the form of TRB\textquotesingle{}s. This helper function takes standard parameters and correctly formats the TRB. The R/W bit is set to ensure that the resulting TRB describes an i2c read operation.

This function does not send the transaction. To send the transaction, the TRB insert function (\mbox{\hyperlink{i2c1_8h_a860d0c61c4bfa0434f345692cd277328}{I2\+C1\+\_\+\+Master\+TRBInsert()}}) must be called.

@\+Preconditions None

@\+Param ptrb -\/ A pointer to a caller supplied TRB.

@\+Param pdata -\/ A pointer to the block of data to be received

@\+Param length -\/ The length of the data block to be received

@\+Param address -\/ The address of the i2c peripheral to be accessed

@\+Returns None

@\+Example {\ttfamily  Refer to \mbox{\hyperlink{i2c1_8h_a860d0c61c4bfa0434f345692cd277328}{I2\+C1\+\_\+\+Master\+TRBInsert()}} for an example ~\newline
 } 

Definition at line 683 of file i2c1.\+c.

\mbox{\Hypertarget{i2c1_8h_a860d0c61c4bfa0434f345692cd277328}\label{i2c1_8h_a860d0c61c4bfa0434f345692cd277328}} 
\index{i2c1.h@{i2c1.h}!I2C1\_MasterTRBInsert@{I2C1\_MasterTRBInsert}}
\index{I2C1\_MasterTRBInsert@{I2C1\_MasterTRBInsert}!i2c1.h@{i2c1.h}}
\doxysubsubsection{\texorpdfstring{I2C1\_MasterTRBInsert()}{I2C1\_MasterTRBInsert()}}
{\footnotesize\ttfamily void I2\+C1\+\_\+\+Master\+TRBInsert (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{count,  }\item[{\mbox{\hyperlink{struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k}{I2\+C1\+\_\+\+TRANSACTION\+\_\+\+REQUEST\+\_\+\+BLOCK}} $\ast$}]{ptrb\+\_\+list,  }\item[{\mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+STATUS}} $\ast$}]{pflag }\end{DoxyParamCaption})}

\begin{DoxyVerb}@Summary
    Inserts a list of i2c transaction requests into the i2c
    transaction queue.

@Description
    The i2c processes lists of transaction requests.  Each transaction
    list is handled as a string of i2c restarts.  When the list of
    transactions is complete, an i2c stop is produced, the flag is set
    with the correct condition code and the next list is processed
    from the queue.

    This function inserts lists of requests prepared by the user
    application into the queue along with a pointer to the completion
    flag.

    The transaction is inserted into the list only if there is space
    in the list. If there is no space, the function exits with the
    flag set to I2C1_MESSAGE_FAIL.

@Preconditions
    None

@Param
    count - The numer of transaction requests in the trb_list.

@Param
     ptrb_list - A pointer to an array of transaction requests (TRB).
        See I2C1_TRANSACTION_REQUEST_BLOCK definition for details.

@Param
     pflag - A pointer to a completion flag.

@Returns
    None

@Example
    <code>


        uint8_t EMULATED_EEPROM_Read(
                                       uint16_t slaveDeviceAddress,
                                       uint16_t dataAddress,
                                       uint8_t *pData,
                                       uint16_t nCount)
        {
            I2C1_MESSAGE_STATUS status;
            I2C1_TRANSACTION_REQUEST_BLOCK readTRB[2];
            uint8_t     writeBuffer[3];
            uint16_t    timeOut, slaveTimeOut;
\end{DoxyVerb}
 this initial value is important status = I2\+C1\+\_\+\+MESSAGE\+\_\+\+PENDING;

build the write buffer first starting address of the EEPROM memory write\+Buffer\mbox{[}0\mbox{]} = (data\+Address $>$$>$ 8); // high address write\+Buffer\mbox{[}1\mbox{]} = (uint8\+\_\+t)(data\+Address); // low low address

we need to create the TRBs for a random read sequence to the EEPROM Build TRB for sending address I2\+C1\+\_\+\+Master\+Write\+TRBBuild( \&read\+TRB\mbox{[}0\mbox{]}, write\+Buffer, 2, slave\+Device\+Address); Build TRB for receiving data I2\+C1\+\_\+\+Master\+Read\+TRBBuild( \&read\+TRB\mbox{[}1\mbox{]}, p\+Data, n\+Count, slave\+Device\+Address);

time\+Out = 0; slave\+Time\+Out = 0;

while(status != I2\+C1\+\_\+\+MESSAGE\+\_\+\+FAIL) \{ now send the transactions I2\+C1\+\_\+\+Master\+TRBInsert(2, read\+TRB, \&status);

wait for the message to be sent or status has changed. while(status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+PENDING) \{ add some delay here

timeout checking check for max retry and skip this byte if (slave\+Time\+Out == SLAVE\+\_\+\+I2\+C\+\_\+\+GENERIC\+\_\+\+SLAVE\+\_\+\+TIMEOUT) return (0); else slave\+Time\+Out++; \}

if (status == I2\+C1\+\_\+\+MESSAGE\+\_\+\+COMPLETE) break;

if status is I2\+C1\+\_\+\+MESSAGE\+\_\+\+ADDRESS\+\_\+\+NO\+\_\+\+ACK, or I2\+C1\+\_\+\+DATA\+\_\+\+NO\+\_\+\+ACK, The device may be busy and needs more time for the last write so we can retry writing the data, this is why we use a while loop here

check for max retry and skip this byte if (time\+Out == SLAVE\+\_\+\+I2\+C\+\_\+\+GENERIC\+\_\+\+RETRY\+\_\+\+MAX) return (0); else time\+Out++;

\} return (1);

\} ~\newline


Definition at line 633 of file i2c1.\+c.

\mbox{\Hypertarget{i2c1_8h_ac1c5623a0a38d361ec389aba34921822}\label{i2c1_8h_ac1c5623a0a38d361ec389aba34921822}} 
\index{i2c1.h@{i2c1.h}!I2C1\_MasterWrite@{I2C1\_MasterWrite}}
\index{I2C1\_MasterWrite@{I2C1\_MasterWrite}!i2c1.h@{i2c1.h}}
\doxysubsubsection{\texorpdfstring{I2C1\_MasterWrite()}{I2C1\_MasterWrite()}}
{\footnotesize\ttfamily void I2\+C1\+\_\+\+Master\+Write (\begin{DoxyParamCaption}\item[{uint8\+\_\+t $\ast$}]{pdata,  }\item[{uint8\+\_\+t}]{length,  }\item[{uint16\+\_\+t}]{address,  }\item[{\mbox{\hyperlink{i2c1_8h_a3aa7471e380d7a4957f9a0eb726c6582}{I2\+C1\+\_\+\+MESSAGE\+\_\+\+STATUS}} $\ast$}]{pstatus }\end{DoxyParamCaption})}

@\+Summary Handles one i2c master write transaction with the supplied parameters.

@\+Description This function prepares a TRB, then inserts it on the i2c queue. Finally, it waits for the transaction to complete and returns the result.

@\+Preconditions None

@\+Param address -\/ The address of the i2c peripheral to be accessed

@\+Param length -\/ The length of the data block to be sent

@\+Param pdata -\/ A pointer to the block of data to be sent

@\+Param pstatus -\/ A pointer to the status variable that the i2c driver updates during the execution of the message.

@\+Returns I2\+C1\+\_\+\+MESSAGE\+\_\+\+STATUS

@\+Example {\ttfamily  Refer to \mbox{\hyperlink{i2c1_8h_a0d2688c99f12f3c79e9867b3f48a4b70}{I2\+C1\+\_\+\+Initialize()}} and \mbox{\hyperlink{i2c1_8h_a80893177a8cb40f7c30c9932bc5e8006}{I2\+C1\+\_\+\+Master\+Read()}} for an examples ~\newline
 } 

Definition at line 590 of file i2c1.\+c.

\mbox{\Hypertarget{i2c1_8h_a0ec0129336e0fcb629eeb55210707c2d}\label{i2c1_8h_a0ec0129336e0fcb629eeb55210707c2d}} 
\index{i2c1.h@{i2c1.h}!I2C1\_MasterWriteTRBBuild@{I2C1\_MasterWriteTRBBuild}}
\index{I2C1\_MasterWriteTRBBuild@{I2C1\_MasterWriteTRBBuild}!i2c1.h@{i2c1.h}}
\doxysubsubsection{\texorpdfstring{I2C1\_MasterWriteTRBBuild()}{I2C1\_MasterWriteTRBBuild()}}
{\footnotesize\ttfamily void I2\+C1\+\_\+\+Master\+Write\+TRBBuild (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_i2_c1___t_r_a_n_s_a_c_t_i_o_n___r_e_q_u_e_s_t___b_l_o_c_k}{I2\+C1\+\_\+\+TRANSACTION\+\_\+\+REQUEST\+\_\+\+BLOCK}} $\ast$}]{ptrb,  }\item[{uint8\+\_\+t $\ast$}]{pdata,  }\item[{uint8\+\_\+t}]{length,  }\item[{uint16\+\_\+t}]{address }\end{DoxyParamCaption})}

@\+Summary This function populates a trb supplied by the calling function with the parameters supplied by the calling function.

@\+Description All i2c requests are in the form of TRB\textquotesingle{}s. This helper function takes standard parameters and correctly formats the TRB. The R/W bit is cleared to ensure that the resulting TRB describes an i2c write operation.

This function does not send the transaction. To send the transaction, the TRB insert function (\mbox{\hyperlink{i2c1_8h_a860d0c61c4bfa0434f345692cd277328}{I2\+C1\+\_\+\+Master\+TRBInsert()}}) must be called.

@\+Preconditions None

@\+Param ptrb -\/ A pointer to a caller supplied TRB.

@\+Param pdata -\/ A pointer to the block of data to be sent

@\+Param length -\/ The length of the data block to be sent

@\+Param address -\/ The address of the i2c peripheral to be accessed

@\+Returns None

@\+Example {\ttfamily  Refer to \mbox{\hyperlink{i2c1_8h_a860d0c61c4bfa0434f345692cd277328}{I2\+C1\+\_\+\+Master\+TRBInsert()}} for an example ~\newline
 } 

Definition at line 696 of file i2c1.\+c.

